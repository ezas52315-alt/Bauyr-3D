<!DOCTYPE html>
<html lang="kk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>М. Қабанбаев - «Бауыр» әңгімесі</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #040406;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .author-title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 1.1rem;
            letter-spacing: 3px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 200, 100, 0.5);
            font-weight: 300;
            margin-bottom: -5px;
        }

        #shape-description {
            color: #fff;
            font-size: 1.3rem;
            line-height: 1.4;
            letter-spacing: 0.5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-width: 900px;
            text-shadow: 0 0 8px rgba(255,255,255,0.4);
            transition: all 0.5s ease;
        }

        .instructions {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            letter-spacing: 2px;
            animation: pulse 2s infinite alternate;
        }

        @keyframes pulse {
            0% { opacity: 0.5; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 20;
            font-size: 1.5rem;
            letter-spacing: 3px;
            text-shadow: 0 0 20px rgba(255,200,100,0.8);
            transition: opacity 1s ease-out;
        }

        /* Мобильді құрылғыларға арналған стильдер */
        @media (max-width: 768px) {
            #shape-description { font-size: 1rem; padding: 12px 15px; }
            .author-title { font-size: 0.9rem; }
        }
    </style>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">СИМВОЛДАР ЖҮКТЕЛУДЕ...</div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="author-title">Марат Қабанбаев</div>
        <div id="shape-description">«Бауыр» — шығарманың бас тақырыбы (Қос ұғым)</div>
        <div class="instructions">Келесі символға өту үшін экранды басыңыз</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Мәтіндік түсіндірмелер
        const descriptions = [
            "«Бауыр» — шығарманың бас тақырыбы",
            "Бауыр (Ағза) — сөздің тура, биологиялық мағынасы",
            "Қалғұты — ағайындылардың туған жері, қасиетті алтын бесігі",
            "Манап — бауырына қамқор, қандастық мейірімді аңсаған аға",
            "Қали — бөтен елде тәрбиеленіп, туған ағасын жатсынған іні",
            "4 жас — Қалидың балалар үйіне тапсырылған шағы (Жетімдік басы)",
            "Омбы — Қали тәрбиеленген жат қала, ұлттық тамырдан үзілу",
            "Балалар үйі — тек кеңестік идеологияны жүзеге асырушыларды шығаратын фабрика",
            "11 жыл — Манаптың інісін сарыла іздеген уақыты",
            "Құмсағат — күту азабы, сағыныш пен уақыттың сырғуы",
            "Саман кірпіш — Манаптың әкесіне құрметі (Қалидың бұған мән бермеуі мен салқындығы)",
            "46 өлшемді костюм — қабылданбаған сыйлық, бауырлар арасындағы жатсыну",
            "Көз жасы — соғыс қасіреті, үзілген байланыс пен мұң"
        ];

        // --- SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x040406, 0.025); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = window.innerWidth < 768 ? 16 : 10; 
        camera.position.y = 1;
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            2.2,  
            0.5,  
            0.15  
        );
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const PARTICLE_COUNT = 55000; 
        let currentShapeIndex = 0;
        
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        
        // --- SHAPE GENERATORS (СИМВОЛДАР) ---

        const isMobile = window.innerWidth < 768;

        // 1, 3, 4. Жазу генераторы (Бауыр / Манап / Қали) - АНЫҚ (РЕЗКИЙ) НҰСҚА
        function generateText(text) {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            const canvas = document.createElement('canvas');
            canvas.width = 1800; // Сөздердің толық сыюы үшін ұзартылды
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 320px "Segoe UI", Arial, sans-serif'; 
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const validPixels = [];
            
            for (let y = 0; y < canvas.height; y += 3) { 
                for (let x = 0; x < canvas.width; x += 3) {
                    const alphaIndex = (y * canvas.width + x) * 4 + 3;
                    if (imgData[alphaIndex] > 128) {
                        validPixels.push({ x: x - canvas.width / 2, y: canvas.height / 2 - y });
                    }
                }
            }

            const textScale = isMobile ? 0.009 : 0.020; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pixel = validPixels[i % validPixels.length];
                const jitter = isMobile ? 0.01 : 0.02; 
                
                arr[i * 3] = (pixel.x * textScale) + (Math.random() - 0.5) * jitter;
                arr[i * 3 + 1] = (pixel.y * textScale) + (Math.random() - 0.5) * jitter;
                arr[i * 3 + 2] = (Math.random() - 0.5) * 0.1; 
            }
            return arr;
        }

        // 2. Адам ағзасы - Печень (Liver)
        function generateLiver() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * Math.PI * 2;
                const v = Math.acos(2 * Math.random() - 1);
                
                let x = 4.0 * Math.sin(v) * Math.cos(u);
                let y = 2.5 * Math.sin(v) * Math.sin(u);
                let z = 2.0 * Math.cos(v);
                
                x += 1.0; 
                let scale = 1.0 + x * 0.15; 
                if(scale < 0.1) scale = 0.1;
                x *= scale; y *= scale; z *= scale;
                x -= y * y * 0.1;

                const depth = Math.random();
                x *= depth; y *= depth; z *= depth;

                arr[i * 3] = x;
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 5. Құмсағат (11 жылдық іздеу уақыты)
        function generateHourglass() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const y = (Math.random() - 0.5) * 7; 
                const maxR = 2.8;
                const r = Math.max(0.2, (Math.abs(y) / 3.5) * maxR); 
                
                let finalR = r;
                if (Math.random() > 0.3) {
                    finalR = r; 
                } else {
                    if (y < 0) finalR = Math.random() * r;
                    else finalR = Math.random() * r * 0.15; 
                }
                
                const theta = Math.random() * Math.PI * 2;
                arr[i * 3] = finalR * Math.cos(theta);
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = finalR * Math.sin(theta);
            }
            return arr;
        }

        // Саман кірпіш (Әке бейіті) - ЖАҢА ОБРАЗ
        function generateBrick() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x = (Math.random() - 0.5) * 5.0; // Ұзындығы
                let y = (Math.random() - 0.5) * 1.8; // Биіктігі
                let z = (Math.random() - 0.5) * 2.8; // Ені

                // Негізгі беттері (сыртқы қабырғалары)
                if (Math.random() > 0.4) { 
                    const face = Math.floor(Math.random() * 3);
                    if (face === 0) x = Math.sign(x) * 2.5;
                    else if (face === 1) y = Math.sign(y) * 0.9;
                    else z = Math.sign(z) * 1.4;
                }

                // Саманның (балшық пен сабанның) бұдыр фактурасы
                const jitter = Math.random() > 0.9 ? 0.4 : 0.1; 
                x += (Math.random() - 0.5) * jitter;
                y += (Math.random() - 0.5) * jitter;
                z += (Math.random() - 0.5) * jitter;

                arr[i * 3] = x;
                arr[i * 3 + 1] = y - 1.0; 
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 6. Балалар үйі (Нақты геометриялық форма)
        function generateHouse() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                const r = Math.random();
                if (r < 0.6) {
                    const side = Math.floor(Math.random() * 4);
                    x = (Math.random() - 0.5) * 5;
                    y = (Math.random() - 0.5) * 3 - 1.5; 
                    z = (Math.random() - 0.5) * 5;
                    
                    if (side === 0) x = -2.5;
                    else if (side === 1) x = 2.5;
                    else if (side === 2) z = -2.5;
                    else if (side === 3) z = 2.5;
                } else {
                    x = (Math.random() - 0.5) * 6; 
                    z = (Math.random() - 0.5) * 6;
                    const maxDist = Math.max(Math.abs(x), Math.abs(z));
                    y = 0 + (3 - maxDist) * 1.2; 
                    if(y < 0) y = 0;
                }

                arr[i * 3] = x;
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 7. 46 өлшемді Костюм (Салқындық, жатсыну символы)
        function generateSuit() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z = (Math.random() - 0.5) * 0.8; 
                let r = Math.random();
                
                if (r < 0.55) {
                    x = (Math.random() - 0.5) * 4.5; 
                    y = (Math.random() - 0.5) * 6.5 - 0.5; 
                    if (y > 0.5 && Math.abs(x) < (y - 0.5) * 0.9) {
                        x += (x > 0 ? 1 : -1) * 1.5; 
                    }
                } else if (r < 0.77) {
                    let t = Math.random();
                    let w = (Math.random() - 0.5) * 1.2;
                    x = -2.4 - t * 1.5 + w;
                    y = 2.2 - t * 5.0;
                } else {
                    let t = Math.random();
                    let w = (Math.random() - 0.5) * 1.2;
                    x = 2.4 + t * 1.5 + w;
                    y = 2.2 - t * 5.0;
                }
                
                arr[i * 3] = x;
                arr[i * 3 + 1] = y;
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // 8. Көз жасы (Қасірет, жетімдік)
        function generateTeardrop() {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = Math.random() * Math.PI; 
                const theta = Math.random() * Math.PI * 2;
                
                const r = Math.sin(t) * Math.exp(-0.4 * t) * 4.0;
                
                let x = r * Math.cos(theta);
                let z = r * Math.sin(theta);
                let y = (2 - t) * 2.5; 
                
                const fill = Math.random();
                x *= fill; z *= fill; 

                arr[i * 3] = x;
                arr[i * 3 + 1] = y - 1; 
                arr[i * 3 + 2] = z;
            }
            return arr;
        }

        // Оқиға желісі бойынша тізбектелген формалар (Барлығы 13 символ)
        const shapes = [
            generateText("Бауыр"),            // 0
            generateLiver(),                  // 1
            generateText("Қалғұты"),          // 2
            generateText("Манап"),            // 3
            generateText("Қали"),             // 4
            generateText("4"),                // 5
            generateText("Омбы"),             // 6
            generateHouse(),                  // 7
            generateText("11"),               // 8
            generateHourglass(),              // 9
            generateBrick(),                  // 10
            generateSuit(),                   // 11
            generateTeardrop()                // 12
        ];

        // Мәтіндік массив индекстері
        const textIndices = [0, 2, 3, 4, 5, 6, 8];

        // Мәнге сай түстер палитрасы (13 түрлі)
        const colorPalettes = [
            [new THREE.Color(1.0, 0.8, 0.4), new THREE.Color(1.0, 1.0, 1.0), new THREE.Color(0.8, 0.5, 0.2)], // 0. Бауыр (Алтын/Ақ)
            [new THREE.Color(0.6, 0.1, 0.2), new THREE.Color(0.8, 0.2, 0.3), new THREE.Color(0.4, 0.0, 0.1)], // 1. Печень (Қою қызыл)
            [new THREE.Color(0.3, 0.8, 0.4), new THREE.Color(0.8, 0.9, 0.5), new THREE.Color(0.1, 0.6, 0.2)], // 2. Қалғұты (Табиғат, Жасыл/Алтын)
            [new THREE.Color(0.8, 0.9, 1.0), new THREE.Color(1.0, 1.0, 1.0), new THREE.Color(0.4, 0.7, 1.0)], // 3. Манап (Үміт, Көгілдір/Ақ)
            [new THREE.Color(0.6, 0.7, 0.8), new THREE.Color(0.8, 0.9, 0.9), new THREE.Color(0.3, 0.4, 0.5)], // 4. Қали (Салқындық, Сұр/Мұзды көк)
            [new THREE.Color(1.0, 0.9, 0.7), new THREE.Color(1.0, 1.0, 1.0), new THREE.Color(0.8, 0.7, 0.5)], // 5. 4 жас (Солып бара жатқан балалық)
            [new THREE.Color(0.2, 0.3, 0.5), new THREE.Color(0.4, 0.5, 0.6), new THREE.Color(0.1, 0.2, 0.3)], // 6. Омбы (Қатал қала, Қою көк)
            [new THREE.Color(0.2, 0.4, 0.6), new THREE.Color(0.5, 0.6, 0.7), new THREE.Color(0.1, 0.2, 0.4)], // 7. Үй (Жетімдік, Суық көк)
            [new THREE.Color(1.0, 0.5, 0.1), new THREE.Color(1.0, 0.8, 0.2), new THREE.Color(0.8, 0.3, 0.0)], // 8. 11 жыл (Уақыт уайымы, Сарғыш/Қызғылт)
            [new THREE.Color(1.0, 0.6, 0.1), new THREE.Color(1.0, 0.8, 0.3), new THREE.Color(0.8, 0.4, 0.0)], // 9. Құмсағат (Уақыт құмы)
            [new THREE.Color(0.7, 0.5, 0.3), new THREE.Color(0.8, 0.7, 0.5), new THREE.Color(0.5, 0.3, 0.1)], // 10. Кірпіш (Балшық, Топырақ, Қоңыр)
            [new THREE.Color(0.2, 0.2, 0.4), new THREE.Color(0.4, 0.4, 0.6), new THREE.Color(0.1, 0.1, 0.2)], // 11. Костюм (Ресмилік, Жатсыну, Қою көк)
            [new THREE.Color(0.3, 0.7, 1.0), new THREE.Color(0.6, 0.9, 1.0), new THREE.Color(0.1, 0.4, 0.8)]  // 12. Көз жасы (Мөлдір көк)
        ];

        for (let i = 0; i < positions.length; i++) {
            positions[i] = shapes[0][i];
            targetPositions[i] = shapes[0][i];
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const randoms = new Float32Array(PARTICLE_COUNT);
        for (let i = 0; i < PARTICLE_COUNT; i++) randoms[i] = Math.random();
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMouse: { value: new THREE.Vector3(0, 0, 0) },
                uColor1: { value: colorPalettes[0][0].clone() },
                uColor2: { value: colorPalettes[0][1].clone() },
                uColor3: { value: colorPalettes[0][2].clone() }
            },
            vertexShader: `
                uniform float uTime;
                uniform vec3 uMouse;
                attribute float aRandom;
                
                varying vec3 vPos;
                varying float vOpacity;

                void main() {
                    vPos = position;
                    vec3 pos = position;

                    float dist = distance(pos, uMouse);
                    float maxDist = 3.0;
                    if (dist < maxDist) {
                        vec3 dir = normalize(pos - uMouse);
                        float force = pow((maxDist - dist) / maxDist, 2.0); 
                        pos += dir * force * 1.5; 
                    }

                    pos.x += sin(uTime * 1.0 + aRandom * 10.0) * 0.03;
                    pos.y += cos(uTime * 0.8 + pos.x) * 0.03;
                    pos.z += sin(uTime * 1.2 + pos.y) * 0.03;

                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    
                    gl_PointSize = (22.0 * aRandom + 6.0) * (1.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;

                    vOpacity = 0.4 + 0.6 * sin(uTime * 2.0 + aRandom * 20.0);
                }
            `,
            fragmentShader: `
                uniform float uTime;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;
                
                varying vec3 vPos;
                varying float vOpacity;

                void main() {
                    vec2 cxy = 2.0 * gl_PointCoord - 1.0;
                    float r = dot(cxy, cxy);
                    if (r > 1.0) discard;
                    
                    float alpha = (1.0 - r) * vOpacity;

                    float mix1 = sin(vPos.x * 0.5 + uTime * 0.5) * 0.5 + 0.5;
                    float mix2 = cos(vPos.y * 0.5 - uTime * 0.3) * 0.5 + 0.5;

                    vec3 finalColor = mix(mix(uColor1, uColor2, mix1), uColor3, mix2);
                    
                    finalColor *= 1.5;

                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        setTimeout(() => {
            document.getElementById('loading').style.opacity = '0';
        }, 1200);

        const descElement = document.getElementById('shape-description');

        window.addEventListener('click', () => {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            const newShape = shapes[currentShapeIndex];
            
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                targetPositions[i] = newShape[i];
            }

            descElement.style.opacity = '0';
            setTimeout(() => {
                descElement.innerText = descriptions[currentShapeIndex];
                descElement.style.opacity = '1';
            }, 300);
        });

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(999, 999);
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const targetMousePos = new THREE.Vector3(999, 999, 0);

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, targetMousePos);
        });

        window.addEventListener('touchmove', (event) => {
            if(event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                raycaster.ray.intersectPlane(plane, targetMousePos);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.position.z = window.innerWidth < 768 ? 16 : 10;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            material.uniforms.uTime.value = elapsedTime;

            material.uniforms.uColor1.value.lerp(colorPalettes[currentShapeIndex][0], 0.05);
            material.uniforms.uColor2.value.lerp(colorPalettes[currentShapeIndex][1], 0.05);
            material.uniforms.uColor3.value.lerp(colorPalettes[currentShapeIndex][2], 0.05);

            material.uniforms.uMouse.value.lerp(targetMousePos, 0.1);

            const posAttr = geometry.attributes.position;
            const posArray = posAttr.array;
            let needsUpdate = false;

            for (let i = 0; i < posArray.length; i++) {
                const current = posArray[i];
                const target = targetPositions[i];
                const diff = target - current;
                
                if (Math.abs(diff) > 0.001) {
                    posArray[i] += diff * 0.05; 
                    needsUpdate = true;
                }
            }

            if (needsUpdate) posAttr.needsUpdate = true;

            // Егер мәтін немесе сан болса, айналуды тоқтатамыз
            if (textIndices.includes(currentShapeIndex)) { 
                let currentY = particles.rotation.y;
                let nearest2Pi = Math.round(currentY / (Math.PI * 2)) * (Math.PI * 2);
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, nearest2Pi, 0.05);
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, 0, 0.05);
            } else {
                // Қалған образдар баяу айналып тұрады
                particles.rotation.y += 0.003;
                particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, Math.sin(elapsedTime * 0.3) * 0.1, 0.02);
            }

            composer.render();
        }

        animate();
    </script>
</body>
</html>